<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Bracho CPU]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>Bracho CPU</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 05 Jun 2024 22:43:52 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 05 Jun 2024 22:43:49 GMT</pubDate><copyright><![CDATA[brahim ghouma]]></copyright><ttl>60</ttl><dc:creator>brahim ghouma</dc:creator><item><title><![CDATA[ALU]]></title><description><![CDATA[ 
 <br><br><br>An arithmetic-logic unit is the part of a central processing unit that carries out arithmetic and bitwise operations (logic operations using <a data-tooltip-position="top" aria-label="Exploring How Computers Work > Logic gates" data-href="Exploring How Computers Work#Logic gates" href="bracho-cpu\exploring-how-computers-work.html#Logic_gates" class="internal-link" target="_self" rel="noopener">logic gates</a> ) on the operands in computer instruction words.<br>The inputs of an ALU are:<br>
<br>Operands: Which are the data to be operated on.
<br>Opcode: A code indicating the operation to be performed.
<br>status (in): Information about a previous operation.<br>
The outputs of an ALU are:
<br>Result: The result of the operation.
<br>Status (out): Information about the operation.
<br><img alt="ALU_block.gif" src="lib\media\alu_block.gif"><br>
A symbolic representation of an ALU and its input and output signals, indicated by arrows pointing into or out of the ALU, respectively. Each arrow represents one or more signals. Control signals enter from the left and status signals exit on the right; data flows from top to bottom. | <a rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit" target="_blank">https://en.wikipedia.org/wiki/Arithmetic_logic_unit</a>
<br>e.g. The famous 74S181 4-bit ALU<br>
<img alt="ALU-20240514212757041.webp" src="lib\media\alu-20240514212757041.webp"><br>
The combinational logic circuitry of the 74181 integrated circuit, an early four-bit ALU, with logic gates | <a rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/74181" target="_blank">https://en.wikipedia.org/wiki/74181</a>
<br><br>Typically, the ALU has direct input and output access to RAM and the Registers through the data bus. BUT first, We have to make something clear The ALU does not work on it own (e.i. it does not know how to get the data from any register let only get it from RAM, And it does know what operation it should do.), The ALU requires some kind of control unit to tell it what operation to do and the data it should do it on.<br>The control unit or CU for short, Interprets instruction words, sometimes called a machine instruction words, that contains an operation code or "opcode," one or more operands and sometimes a format code.  The CU decodes the operation code and tells the ALU what operation to perform and the operands are used in the operation.<br>The output of the ALU is connected to ACC. ACC receives, and temporarily stores, the result of the most recent ALU operation. The output of ACC is then connected to the bus, so its contents can be sent somewhere else as needed.<br><img alt="ALU-20240514160244770.webp" src="lib\media\alu-20240514160244770.webp" style="width: 693px; max-width: 100%;"><br><br>note:<a rel="noopener" class="external-link" href="https://www.tutorialandexample.com/cpu-registers" target="_blank">https://www.tutorialandexample.com/cpu-registers</a><br>
Accumulator (AC)<br>Accumulator register is used to store the result of ALU (arithmetic logic unit) operations and sometimes store one of ALU inputs.<br>&nbsp;General Architecture -During operation, ALU generally required two inputs (it can be one) called operands.&nbsp; ALU performs operations ( like addition, subtraction, division, multiplication etc.) on the input operand, and after performing operations, ALU generates results. In basic Storage design, these results are generated firstly in Accumulator, and then further it is copied or transferred to the user requirement, it may be memory or register.<br>Accumulator based architecture - A specific architecture/ design of CPU says that when CPU takes two inputs, and both the inputs should be going for ALU, one of the inputs should be taken from Accumulator, and the other input can be taken from anywhere. The result of the performed operation is stored in Accumulator, and this specific design is called Accumulator based architecture.<br><br><br>The ALU that we are going to design <a data-tooltip-position="top" aria-label="ALU.excalidraw" data-href="ALU.excalidraw" href="bracho-cpu\drawing\alu.excalidraw.html" class="internal-link" target="_self" rel="noopener">ALU Drawing</a><br><img alt="ALU-20240514161607685.webp" src="lib\media\alu-20240514161607685.webp"><br><br>
<br>NOT
<br>AND
<br>OR
<br>XOR
<br><br>
<br>addition
<br>substruction
<br>multiplication
<br>division
<br><br>
<br>shift left
<br>shift right
<br><br><a data-href="The instruction set" href="bracho-cpu\components\alu\the-instruction-set.html" class="internal-link" target="_self" rel="noopener">The instruction set</a>]]></description><link>bracho-cpu\components\alu\alu.html</link><guid isPermaLink="false">Bracho-CPU/Components/ALU/ALU.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Tue, 14 May 2024 20:33:53 GMT</pubDate><enclosure url="lib\media\alu_block.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\alu_block.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[arithmetic operations]]></title><description><![CDATA[ 
 ]]></description><link>bracho-cpu\components\alu\arithmetic-operations.html</link><guid isPermaLink="false">Bracho-CPU/Components/ALU/arithmetic operations.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Tue, 14 May 2024 20:35:26 GMT</pubDate></item><item><title><![CDATA[Bit shift operations]]></title><description><![CDATA[ 
 ]]></description><link>bracho-cpu\components\alu\bit-shift-operations.html</link><guid isPermaLink="false">Bracho-CPU/Components/ALU/Bit shift operations.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Tue, 14 May 2024 20:35:39 GMT</pubDate></item><item><title><![CDATA[bitwise operations]]></title><description><![CDATA[ 
 ]]></description><link>bracho-cpu\components\alu\bitwise-operations.html</link><guid isPermaLink="false">Bracho-CPU/Components/ALU/bitwise operations.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Tue, 14 May 2024 20:35:13 GMT</pubDate></item><item><title><![CDATA[The instruction set]]></title><description><![CDATA[ 
 <br>NOP                     : No Operation
AND                     : REG_A &lt;= REG_B AND REG_C
OR                      : REG_A &lt;= REG_B OR REG_C
NOT                     : REG_A &lt;= NOT(REG_A)
ADD                     : REG_A &lt;= REG_B + REG_C
SUB                     : REG_A &lt;= REG_B - REG_C
MULT                    : REG_A &lt;= REG_B * REG_C
DIV                     : REG_A &lt;= REG_B / REG_C
LDA #value              : load immediate value to REG_A [value should be between -2048 and 2048]
LDB #value              : load immediate value to REG_B (we can remove this and use swap to fill them)
LDC #value              : load immediate value to REG_C (we can remove this and use swap to fill them)
AIN [REG_B]|&lt;offset&gt;    : Load data from the given address into registerâ€„A [offset should be between 0 and 512]
BIN [REG_A]|&lt;offset&gt;    :
CIN [REG_A]|&lt;offset&gt;    :
STA [REG_B]|&lt;offset&gt;    :
STB [REG_A]|&lt;offset&gt;    :
STC [REG_A]|&lt;offset&gt;    :
PCR                     : Get the current program counter value and put it into register A
LDWB                    : Load value directly after counter into register B and advance program counter by 2
SHR                     : Right shift the register A value by the value in resgister B
SHL                     : left shift the register A value by the value in resgister B
SWAB                    : Swap the values of register A and B (overwrite register C)
SWAC                    : Swap the values of register A and C (overwrite register B)
SWBC                    : Swap the values of register B and C (overwrite register A)
LD                      : Load the value at the current address of Program counter register and store the value in the instruction Register and advance program counter by 2
BR                      : Branch to the addres of register A
BRN                     : Branch to the addres of register A if the negative flag is on
BRZ                     : Branch to the addres of register A if the zero flag is on
BRV                     : Branch to the addres of register A if the overflow flag is on
Copy]]></description><link>bracho-cpu\components\alu\the-instruction-set.html</link><guid isPermaLink="false">Bracho-CPU/Components/ALU/The instruction set.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Tue, 14 May 2024 20:30:58 GMT</pubDate></item><item><title><![CDATA[Transistors]]></title><description><![CDATA[ 
 <br><br>**Transistor** consists of **three layers of semiconductor** materials or terminals which helps to make a connection to any external circuit and all the layers do carry the current. Here voltage or current applied at any one pair of the terminals controls the current or voltage through the other pair of terminals.<br>There are three terminals for transistor as mentioned below:<br>
<br>**Base:** To activate the transistor
<br>**Collector:** Positive lead of transistor
<br>**Emitter:** Negative lead of transistor
<br><img alt="Transistor-20240514192225339.webp" src="lib\media\transistor-20240514192225339.webp">

NPN Transistor Tutorial - The Bipolar NPN Transistor | electronics-tutorials.ws


<br><br>A Transistor can be classified into various categories, however other types of transistors are there but we are going to discuss two main types as mentioned below:<br>
<br>**Bipolar Junction Transistor**
<br>**Field effect transistor**
<br><br>This type of Transistor is considered one of the most common types of transistors. BJT transistor consists of three terminals that is **emitter, base, and collector**. It can able to amplify the electrical signal by joining all three layers into one. In current flow, there are two types of electrical charges involved i.e., electrons and holes.<br>The BJT can be further classified as PNP and NPN Transistor<br>
<br>**P-N-P Transistor:** In P-N-P configuration the Holes are the majority charge carrier. When emitter injects holes into the transistor when the emitter-base junction is forward biased. These flow into base region which controls the current passing from emitter to the collector. The base control this flow and the collector collects the holes. By reverse biasing the collector base junction the flow is controlled which enables modulation of the collector current by the base current.
<br>**N-P-N Transistor:** In N-P-N configuration electrons are the majority charge carriers. Electrons flow from emitter to collector when the emitter-base junction is forward biased. The base controls this flow and the collector collects the electrons. By reverse biasing the collector-base junction the flow is controlled by regulating the collector current.
<br><img alt="npn-vs-pnp-transistor-3614303086.gif" src="lib\media\npn-vs-pnp-transistor-3614303086.gif"><br>
NPN VS PNP Transistor Understanding the Difference | <a data-tooltip-position="top" aria-label="https://www.componentsinfo.com/npn-vs-pnp-transistor/" rel="noopener" class="external-link" href="https://www.componentsinfo.com/npn-vs-pnp-transistor/" target="_blank">componentsinfo.com</a>
<br><br>This type of transistor is a **three-terminal semiconductor** device. Its operation is based on a controlled input voltage. It uses an electric field to control the field of electric current in a semiconductor. They are also known as **unipolar transistors** since they **contain single-carrier-type operations**. FET uses either electrons or holes as charge carriers for the operation but does not use both electrons and holes. They display high input impedance at low frequencies.<br>There are **two types of FET** as mentioned below:<br>
<br>**JFET** â€“ Junction-gate FET
<br>**MOSFET** â€“ Metal-oxide semiconductor FET
<br><img alt="Transistor-20240514191854998.webp" src="lib\media\transistor-20240514191854998.webp"><br>
MOSFET VS JFET | The Main Differences - ETechnoG | <a data-tooltip-position="top" aria-label="https://www.etechnog.com/2019/07/mosfet-vs-jfet-differences.html" rel="noopener" class="external-link" href="https://www.etechnog.com/2019/07/mosfet-vs-jfet-differences.html" target="_blank">etechnog.com</a>
]]></description><link>bracho-cpu\components\transistors.html</link><guid isPermaLink="false">Bracho-CPU/Components/Transistors.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Tue, 14 May 2024 20:26:03 GMT</pubDate><enclosure url="lib\media\transistor-20240514192225339.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\transistor-20240514192225339.webp&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Exploring How Computers Work]]></title><description><![CDATA[ 
 <br><br><br><br>They is one component that rises above all other component in it importance in making computers do STUFF, and that component is the humble transistor. <br>
A transistor is a <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Semiconductor" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Semiconductor" target="_blank">semiconductor</a> device used to amplify or switch electrical signals and power. It is one of the basic building blocks of modern electronics.
<br><br><br><img alt="Exploring How Computers Work-20240514164522871.webp" src="lib\media\exploring-how-computers-work-20240514164522871.webp" style="width: 554px; max-width: 100%;"><br>
Typical structure of a transistor consisting of an emitter, collector and base. | Image: Shutterstock
<br>Transistors are fundamental components in modern electronics, serving two main roles:<br>
<br>Amplification: a transistor can amplify a weak signal into a stronger one.
<br>Switching: In digital electronics, transistors are used as switches to control the flow of electricity in circuits, representing binary states (0 or 1).
<br>In learning how computers work we gonna focus on the switching role of a transistor if you wish to learn more about <a data-href="Transistors" href="bracho-cpu\components\transistors.html" class="internal-link" target="_self" rel="noopener">Transistors</a>.<br><br>Have you ever wounded how logic gates are made, I didn't but a was surprised when i learned they can be made using transistors.<br><br>A logic gate is a device that performs a Boolean function, a logical operation performed on one or more binary inputs that produces a single binary output.<br><br><br><img alt="Exploring How Computers Work-20240514201240964.webp" src="lib\media\exploring-how-computers-work-20240514201240964.webp" style="width: 506px; max-width: 100%;"><br><br><br><img alt="Exploring How Computers Work-20240514202034917.webp" src="lib\media\exploring-how-computers-work-20240514202034917.webp" style="width: 517px; max-width: 100%;"><br><br><br><img alt="Exploring How Computers Work-20240605230016790.webp" src="lib\media\exploring-how-computers-work-20240605230016790.webp"><br><br>note: did know you can create any logic using just XOR gates or using just NAND gates <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Logic_gate#Universal_logic_gates" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Logic_gate#Universal_logic_gates" target="_blank">click here</a> to learn more.<br><br>Everyone knows that computers manipulate binary numbers (e.i. a bunch of ones and zeros), But how code is transformed form human readable text to binary instructions that can be interpreted  and then executes by a CPU?<br><br>we gonna take this C++ code us an example.<br>int main()
{
    int a = 5;
    int b = a+7;
}
Copy<br>So how this code is going to be return into binary instructions?<br>
using an other Programmed called the Compiler in the case of C++ it compiler is called "g++"<br>
We can compile the .cpp file into a binary executable:<br>g++ Main.cpp -o Program.exe
Copy<br>The compiler is gonna turn the C++ code into the appropriate assembly language (assembly is the lowest level of programming) that can be easily transformed into binary instructions.<br>This the assembly version the C++ code <br>mov     r0, #5
add     r1, r0, #7
Copy<br>mov and add are called Opcodes and each one has a unique binary code signed to it.<br>
For example let's say the code for mov is 0001 and add is 0011 <br>
Notice that every opcode in our case have the same length of 4 bit, And this is because our hypothetical the CPU expects the first 4 bits of every instruction to be the opcode.
<br>the assembly version cloud be writing like this<br>001     r0, #5
011     r1, r0, #7
Copy<br>Let's talk about r0 what it is? it is the short way to write register 0.<br>
But what is a register? a register in temporary data storage inside the CPU, is a type of storage that is extremely fast but extremely small in size.<br>This assembly instruction mov     r0, #5 is telling the CPU  to move the value 5 to the register 0.<br>
Then this instruction add     r1, r0, #7 is telling the CPU to add the value 7 to what every inside the register 0 and store the result of the operation inside register 1. (This instruction is equivalent to:  register1 = 7 + register0)<br>Let's suppose the binary code for register 0 is 0000 and the binary code for register 1 is 0001<br>
the new assembly code version :<br>0001     0000, #5
0011     0001, 0000, #9
Copy<br>And we know that 101 is the number 5 in binary and 111 is the number 7<br>001     0000, 0101
011     0001, 0000, 0111
Copy<br>But all instructions should be the same length (in our case every instruction should be 16bit long) so  we are going to 0000 at the end of the fist instruction.<br>0001     0000, 0101, 0000
0011     0001, 0000, 0111
Copy<br>So our binary executable is:<br>0001000001010000
0011000100000111
Copy<br>
note: this over simplification for the process of turning code to binary executable.
<br>Next <a data-tooltip-position="top" aria-label="How computers remember" data-href="How computers remember" href="bracho-cpu\how-computers-remember.html" class="internal-link" target="_self" rel="noopener">how registers store data</a>  Or <a data-tooltip-position="top" aria-label="How Buses Work" data-href="How Buses Work" href="bracho-cpu\how-buses-work.html" class="internal-link" target="_self" rel="noopener">how data moves inside a computer</a>]]></description><link>bracho-cpu\exploring-how-computers-work.html</link><guid isPermaLink="false">Bracho-CPU/Exploring How Computers Work.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Wed, 05 Jun 2024 22:00:18 GMT</pubDate><enclosure url="lib\media\exploring-how-computers-work-20240514164522871.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\exploring-how-computers-work-20240514164522871.webp&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[How Buses Work]]></title><description><![CDATA[ 
 ]]></description><link>bracho-cpu\how-buses-work.html</link><guid isPermaLink="false">Bracho-CPU/How Buses Work.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Tue, 14 May 2024 20:25:04 GMT</pubDate></item><item><title><![CDATA[How computers remember]]></title><description><![CDATA[ 
 <br>There are many types of electronic memory used in computers, each with its own advantages and disadvantages.<br>
<img alt="How computers remember-20240605231017365.webp" src="lib\media\how-computers-remember-20240605231017365.webp"><br>
Memory hierarchy | <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Memory_hierarchy" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Memory_hierarchy" target="_blank">Wikipedia</a>
<br>E.g. A hard drive have a large storage capacity and slow mean while ram is medium capacity and fast.<br>
If your computer's CPU had to access the hard drive for every piece of data it needed, it would operate extremely slowly. To ensure the CPU performs at its full potential, programs are loaded into RAM, allowing the CPU to execute them more quickly. However, even RAM isn't fast enough for optimal performance. To address this, we needed a faster and closer (to the cpu) type of memory, ideally located within the CPU itself to minimize delay. The solution is registers.]]></description><link>bracho-cpu\how-computers-remember.html</link><guid isPermaLink="false">Bracho-CPU/How computers remember.md</guid><dc:creator><![CDATA[brahim ghouma]]></dc:creator><pubDate>Wed, 05 Jun 2024 22:33:08 GMT</pubDate><enclosure url="lib\media\how-computers-remember-20240605231017365.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\how-computers-remember-20240605231017365.webp&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>